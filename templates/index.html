<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codex Search - Find Passages in Your Favorite Books</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d3748; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }
        /* Placeholder text style */
        ::placeholder { color: #a0aec0; opacity: 1; }
        /* Title pulse animation */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .8; } }
        .title-pulse { animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        /* Styling for active toggle button */
        .book-toggle-active { background-color: #6b46c1; border-color: #5b21b6; color: #ffffff; }
        /* Styling for inactive toggle button */
        .book-toggle-inactive { background-color: #4a5568; border-color: #2d3748; color: #e2e8f0; }
        .book-toggle-inactive:hover { background-color: #718096; }
        /* Feedback text area styling */
        .feedback-textarea {
            background-color: #2d3748; /* gray-800 */
            border: 1px solid #4a5568; /* gray-600 */
            color: #e2e8f0; /* gray-200 */
        }
        .feedback-textarea:focus {
            outline: none;
            border-color: #6b46c1; /* purple-700 */
            box-shadow: 0 0 0 2px rgba(107, 70, 193, 0.5); /* Ring effect */
        }
        /* Disabled send button style */
        .send-feedback-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Added styles for search button */
        .search-button {
            background-color: #6b46c1; /* purple-700 */
            color: white;
            padding: 0.75rem 1.5rem; /* Adjust padding as needed */
            border: none;
            border-radius: 9999px; /* full */
            font-weight: 500; /* medium */
            transition: background-color 0.15s ease-in-out;
            cursor: pointer;
        }
        .search-button:hover {
            background-color: #5b21b6; /* purple-800 */
        }
        .search-button:focus {
             outline: none;
             box-shadow: 0 0 0 3px rgba(107, 70, 193, 0.4); /* Ring focus */
        }
        .search-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #4a5568; /* gray-600 */
        }
        /* Simple spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            display: inline-block;
            border: 3px solid rgba(196, 181, 253, 0.3); /* purple-300 opacity 30% */
            border-radius: 50%;
            border-top-color: #a78bfa; /* purple-400 */
            width: 1.25rem; /* size-5 */
            height: 1.25rem; /* size-5 */
            animation: spin 1s ease-in-out infinite;
            margin-right: 0.5rem; /* mr-2 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center px-4 py-8">

    <header class="text-center mb-8">
        <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 mb-2 title-pulse">
            Codex Search
        </h1>
        <p class="text-lg text-gray-400">Uncover passages within your favorite fantasy & sci-fi worlds.</p>
    </header>

    <section class="w-full max-w-3xl mb-8">
        <h3 class="text-lg font-semibold text-gray-400 mb-4 text-center">Select Book(s) to Search:</h3>
        <!-- Series/Book Multi-Select Dropdown -->
        <div class="flex flex-wrap justify-center gap-3 mb-4">
            <div class="relative" id="series-dropdown-container">
                <button id="series-dropdown-toggle" class="bg-gray-800 border border-gray-700 text-gray-100 rounded px-4 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500 flex items-center gap-2">
                    <span id="series-dropdown-label">Choose Series/Books</span>
                    <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
                </button>
                <div id="series-dropdown-menu" class="absolute left-0 mt-2 w-72 bg-gray-800 border border-gray-700 rounded shadow-lg z-50 hidden max-h-96 overflow-y-auto">
                    <!-- Dropdown content will be rendered here -->
                </div>
            </div>
        </div>
        <!-- Optionally keep the book-toggle-container for reference, but hide it -->
        <div id="book-toggle-container" class="flex flex-wrap justify-center gap-3 hidden">
            <!-- Book buttons will be dynamically inserted here -->
        </div>
    </section>

    <section class="w-full max-w-2xl mb-4">
        <div class="flex items-center gap-3">
            <div class="relative flex-grow">
                <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none">
                    <svg class="h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" />
                    </svg>
                </div>
                <input
                    type="text"
                    id="searchInput"
                    placeholder="Select a book above and start searching..."
                    class="w-full pl-11 pr-10 py-3 bg-gray-800 border border-gray-700 text-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-300 ease-in-out"
                />
                <!-- Custom Clear Button -->
                <button id="clearSearchButton" class="absolute inset-y-0 right-0 flex items-center pr-3 text-[#ac36c9] hover:text-[#e61947] focus:outline-none" style="display: none;"> <!-- Hidden initially, Changed text color and hover color -->
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <button id="searchButton" class="search-button flex-shrink-0">
                Search
            </button>
        </div>
    </section>

    <section class="w-full max-w-2xl mb-8">
         <p id="select-book-prompt" class="text-center text-yellow-400 text-sm italic">
             Please select a book above to enable search.
         </p>
    </section>

    <section class="w-full max-w-3xl">
        <!-- Modified Heading with Feedback Buttons -->
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-semibold text-gray-300 md:text-left">Result</h2>
            <div class="flex items-center space-x-2">
                 <!-- Moved Feedback Buttons -->
                <div id="global-feedback-buttons" class="flex space-x-2" style="display: none;"> <!-- Initially hidden -->
                    <button id="global-like-button"
                            class="like-button p-2 rounded-full text-green-100 bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-green-500 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                            title="Good Result">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z" />
                        </svg>
                    </button>
                    <button id="global-dislike-button"
                            class="dislike-button p-2 rounded-full text-red-100 bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-red-500 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                            title="Bad Result">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M18 9.5a1.5 1.5 0 11-3 0v-6a1.5 1.5 0 013 0v6zM14 9.667v-5.43a2 2 0 00-1.106-1.79l-.05-.025A4 4 0 0011.057 2H5.642a2 2 0 00-1.962 1.608l-1.2 6A2 2 0 004.44 12H8v4a2 2 0 002 2 1 1 0 001-1v-.667a4 4 0 01.8-2.4l1.2-2.4A4 4 0 0014 9.667z" />
                        </svg>
                    </button>
                </div>
                <!-- Timer Display -->
                <span id="search-timer-indicator" class="ml-4 text-sm text-gray-400"></span>
                <!-- Moved Feedback Sent Message -->
                 <div id="global-feedback-sent-message" class="text-sm text-gray-500" style="display: none;">Feedback Sent!</div>
            </div>
        </div>

        <!-- Loading Indicator (hidden by default) -->
        <div id="loading-indicator" class="hidden text-center text-purple-400 mb-4 flex items-center justify-center">
             <div class="spinner"></div>
             <span>Searching...</span>
        </div>

        <!-- Example Result Card (Template, hidden by default) -->
        <div class="result-card bg-gray-800 border border-gray-700 rounded-lg shadow-lg p-6 mb-6 transition duration-300 hover:shadow-purple-500/30 hidden">
            <p class="result-text text-gray-300 leading-relaxed mb-4">
                Placeholder text...
            </p>
            <div class="flex justify-between items-center mb-3">
                <span class="result-info text-sm text-purple-400 font-medium">Book Name - Chunk Index</span>
                <div class="flex space-x-3">
                    <button title="Good result" class="feedback-button thumbs-up p-2 rounded-full text-gray-400 hover:bg-green-700 hover:text-white transition duration-150 ease-in-out">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                          <path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z" />
                        </svg>
                    </button>
                    <button title="Bad result" class="feedback-button thumbs-down p-2 rounded-full text-gray-400 hover:bg-red-700 hover:text-white transition duration-150 ease-in-out">
                       <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                         <path d="M18 9.5a1.5 1.5 0 11-3 0v-6a1.5 1.5 0 013 0v6zM14 9.667v-5.43a2 2 0 00-1.106-1.79l-.05-.025A4 4 0 0011.057 2H5.642a2 2 0 00-1.962 1.608l-1.2 6A2 2 0 004.44 12H8v4a2 2 0 002 2 1 1 0 001-1v-.667a4 4 0 01.8-2.4l1.2-2.4A4 4 0 0014 9.667z" />
                       </svg>
                    </button>
                </div>
            </div>
            <div class="feedback-input-area hidden mt-3">
                <textarea
                    rows="3"
                    placeholder="What was wrong with this result?"
                    class="feedback-textarea w-full p-2 rounded-md text-sm transition duration-150 ease-in-out mb-2"
                ></textarea>
                <button
                    class="send-feedback-button w-full sm:w-auto bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled
                >
                    Send Feedback
                </button>
            </div>
        </div>

        <!-- Area where dynamic result will be loaded -->
        <div id="results-container" class="mt-6 space-y-4">
            <!-- Results will be dynamically inserted here -->
        </div>

    </section>

    <footer class="mt-16 text-center text-gray-500 text-sm">
        <p>&copy; 2025 Codex Search. All rights reserved.</p>
        <p>Powered by Vector Search & LLMs</p>
    </footer>
    <div class="w-full text-center text-gray-600 text-xs mt-2 mb-1" style="font-size: 0.85em;">
        Version 1.2
    </div>

    <!-- Hidden template for search results -->
    <template id="resultTemplate">
        <div class="bg-white shadow-md rounded-lg p-6 mb-4 fade-in result-card">
            <div class="flex justify-between items-start mb-3">
                <div>
                    <h3 class="text-lg font-semibold text-gray-800 mb-1">Result from: <span class="font-normal book-title"></span></h3>
                    <p class="text-sm text-gray-500">Chunk Index: <span id="chunk-index" class="chunk-index font-medium"></span></p>
                </div>
                <!-- Clipboard Button -->
                <div class="relative">
                    <button class="copy-chunk-btn p-2 rounded-full text-gray-500 hover:bg-purple-100 hover:text-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-400 transition duration-150" title="Copy chunk text to clipboard">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a3 3 0 006 0M9 5a3 3 0 016 0" />
                        </svg>
                    </button>
                    <span class="copy-tooltip absolute right-0 top-0 mt-0 mr-12 bg-purple-600 text-white text-xs rounded px-2 py-1 opacity-0 pointer-events-none transition-opacity duration-300">Copied!</span>
                </div>
            </div>
            <p class="text-gray-700 whitespace-pre-wrap chunk-text"></p>
            <!-- Navigation Buttons -->
            <div class="mt-4 pt-4 border-t border-gray-200 flex justify-between navigation-buttons" style="display: none;">
                <button class="prev-chunk-button px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                    &larr; Previous Chunk
                </button>
                <button class="next-chunk-button px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                    Next Chunk &rarr;
                </button>
            </div>
        </div>
    </template>

    <script>
        // --- Available Books (Passed from Flask) ---
        const availableBooks = JSON.parse('{{ available_books | tojson | safe }}');

        // --- Parse series/books into nested structure ---
        const seriesMap = {};
        availableBooks.forEach(book => {
            const parts = book.filename.split('/');
            const series = parts.length > 1 ? parts[0] : 'Other/Root';
            if (!seriesMap[series]) seriesMap[series] = [];
            seriesMap[series].push(book);
        });
        const seriesList = Object.keys(seriesMap).sort((a, b) => a.localeCompare(b));

        // --- DOM Elements ---
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const resultsContainer = document.getElementById('results-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const selectBookPrompt = document.getElementById('select-book-prompt');
        const clearSearchButton = document.getElementById('clearSearchButton');
        const seriesDropdownToggle = document.getElementById('series-dropdown-toggle');
        const seriesDropdownMenu = document.getElementById('series-dropdown-menu');
        const seriesDropdownLabel = document.getElementById('series-dropdown-label');
        // --- Global Feedback Elements ---
        const globalFeedbackButtonsDiv = document.getElementById('global-feedback-buttons');
        const globalLikeButton = document.getElementById('global-like-button');
        const globalDislikeButton = document.getElementById('global-dislike-button');
        const globalFeedbackSentMessage = document.getElementById('global-feedback-sent-message');
        
        // --- State ---
        let currentChunkIndex = null;
        let totalChunks = 0; // Note: This represents total chunks for the *result* book
        let currentFullChunkText = null;
        let originalChunkIndex = null;
        let chunkFullTextCache = {};
        let currentRank = null;
        let selectedBookFilenames = [];
        let selectedSeries = new Set(); // For quick lookup
        let currentResultBookFilename = null; // Filename associated with the displayed result
        // --- Search Time Tracker ---
        let searchStartTime = null;

        // --- Render Series/Book Dropdown ---
        function renderSeriesDropdown() {
            seriesDropdownMenu.innerHTML = '';
            seriesList.forEach(series => {
                const books = seriesMap[series];
                // Series row
                const seriesId = `series-${series.replace(/[^a-zA-Z0-9]/g, '-')}`;
                const allBooksSelected = books.every(b => selectedBookFilenames.includes(b.filename));
                const someBooksSelected = books.some(b => selectedBookFilenames.includes(b.filename));
                // Series checkbox
                const seriesRow = document.createElement('div');
                seriesRow.className = 'px-4 py-2 border-b border-gray-700 last:border-b-0';
                seriesRow.innerHTML = `
                    <label class="flex items-center cursor-pointer select-none">
                        <input type="checkbox" class="series-checkbox mr-2" id="${seriesId}" ${allBooksSelected ? 'checked' : ''} ${someBooksSelected && !allBooksSelected ? 'indeterminate' : ''}>
                        <span class="font-semibold text-purple-300">${series}</span>
                    </label>
                `;
                // Set indeterminate state after adding to DOM
                setTimeout(() => {
                    const cb = seriesRow.querySelector('.series-checkbox');
                    if (cb) cb.indeterminate = someBooksSelected && !allBooksSelected;
                }, 0);
                // Book checkboxes
                books.forEach(book => {
                    const bookId = `book-${book.filename.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const bookRow = document.createElement('div');
                    bookRow.className = 'pl-7 py-1';
                    bookRow.innerHTML = `
                        <label class="flex items-center cursor-pointer select-none">
                            <input type="checkbox" class="book-checkbox mr-2" id="${bookId}" data-filename="${book.filename}" ${selectedBookFilenames.includes(book.filename) ? 'checked' : ''}>
                            <span class="text-gray-200">${book.display_name}</span>
                        </label>
                    `;
                    seriesRow.appendChild(bookRow);
                });
                seriesDropdownMenu.appendChild(seriesRow);
            });

            // --- Add event listeners for checkboxes ---
            // Series checkboxes
            seriesDropdownMenu.querySelectorAll('.series-checkbox').forEach(cb => {
                cb.addEventListener('change', e => {
                    const series = cb.parentElement.textContent.trim();
                    const books = seriesMap[series];
                    if (cb.checked) {
                        books.forEach(book => {
                            if (!selectedBookFilenames.includes(book.filename)) selectedBookFilenames.push(book.filename);
                        });
                    } else {
                        selectedBookFilenames = selectedBookFilenames.filter(fn => !books.some(b => b.filename === fn));
                    }
                    renderSeriesDropdown();
                    updateSearchInputState();
                });
            });
            // Book checkboxes
            seriesDropdownMenu.querySelectorAll('.book-checkbox').forEach(cb => {
                cb.addEventListener('change', e => {
                    const filename = cb.dataset.filename;
                    if (cb.checked) {
                        if (!selectedBookFilenames.includes(filename)) selectedBookFilenames.push(filename);
                    } else {
                        selectedBookFilenames = selectedBookFilenames.filter(fn => fn !== filename);
                    }
                    renderSeriesDropdown();
                    updateSearchInputState();
                });
            });
        }

        // --- Dropdown open/close logic ---
        seriesDropdownToggle.addEventListener('click', () => {
            seriesDropdownMenu.classList.toggle('hidden');
        });
        document.addEventListener('click', (e) => {
            if (!seriesDropdownMenu.contains(e.target) && !seriesDropdownToggle.contains(e.target)) {
                seriesDropdownMenu.classList.add('hidden');
            }
        });

        // --- Update Search Input State ---
        function updateSearchInputState() {
            // Update label
            const selectedBooks = availableBooks.filter(b => selectedBookFilenames.includes(b.filename));
            const selectedSeriesNames = seriesList.filter(series => {
                const books = seriesMap[series];
                return books.every(b => selectedBookFilenames.includes(b.filename));
            });
            if (selectedBooks.length === 0) {
                seriesDropdownLabel.textContent = 'Choose Series/Books';
                searchInput.placeholder = 'Select book(s) above and start searching...';
                searchInput.disabled = true;
                searchButton.disabled = true;
                if (selectBookPrompt) selectBookPrompt.classList.remove('hidden');
            } else {
                let label = '';
                if (selectedSeriesNames.length > 0) {
                    label += selectedSeriesNames.join(', ');
                }
                const individualBooks = selectedBooks.filter(b => {
                    const series = b.filename.split('/').length > 1 ? b.filename.split('/')[0] : 'Other/Root';
                    return !selectedSeriesNames.includes(series);
                });
                if (individualBooks.length > 0) {
                    if (label) label += ', ';
                    label += individualBooks.map(b => b.display_name).join(', ');
                }
                seriesDropdownLabel.textContent = label;
                searchInput.placeholder = `Searching in: ${label}...`;
                searchInput.disabled = false;
                searchButton.disabled = false;
                if (selectBookPrompt) selectBookPrompt.classList.add('hidden');
            }
            resultsContainer.innerHTML = '';
            // Reset other state as before
            currentChunkIndex = null;
            totalChunks = 0;
            currentResultBookFilename = null;
            if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none';
            if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
            resetGlobalFeedbackButtons();
            currentRank = null;
        }

        // --- Initial Render ---
        renderSeriesDropdown();
        updateSearchInputState();

        // --- Clear Search Button Logic ---
        if (searchInput && clearSearchButton) {
            searchInput.addEventListener('input', () => {
                clearSearchButton.style.display = searchInput.value.length > 0 ? 'flex' : 'none';
            });
            clearSearchButton.addEventListener('click', () => {
                searchInput.value = ''; 
                clearSearchButton.style.display = 'none'; 
                searchInput.focus(); 
            });
        }

        // --- Trigger Search Function ---
        async function triggerSearch() {
            if (selectedBookFilenames.length === 0 || searchInput.value.trim() === '') {
                console.log('Search not triggered: Book(s) not selected or query empty.');
                return;
            }
            const query = searchInput.value.trim();
            console.log(`Triggering search for: "${query}" in books: ${selectedBookFilenames.join(', ')}`);

            resultsContainer.innerHTML = '';
            if(loadingIndicator) loadingIndicator.classList.remove('hidden');
            searchInput.disabled = true;
            searchButton.disabled = true;
            console.log('%cStarting search process...', 'color: #a78bfa;');

            // Start timing
            searchStartTime = performance.now();
            // Clear timer display
            const timerIndicator = document.getElementById('search-timer-indicator');
            if (timerIndicator) timerIndicator.textContent = '';

            try {
                const response = await fetch('/search', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ query: query, book_filenames: selectedBookFilenames })
                });
                const responseData = await response.json();
                if (!response.ok) {
                    throw new Error(responseData.error || `HTTP error! status: ${response.status}`);
                }
                console.log(`%cSearch function ${responseData.search_completed ? 'completed' : 'did not complete'}.`, 
                            responseData.search_completed ? 'color: #34d399;' : 'color: #f87171;');
                
                displayResults(responseData.results || []); // Pass results list
                console.log('%cSearch display complete.', 'color: #60a5fa;');

            } catch (error) {
                currentChunkIndex = null; 
                totalChunks = 0;
                currentResultBookFilename = null;
                console.error('Search failed:', error);
                resultsContainer.innerHTML = '';
                const errorMsgElement = document.createElement('p');
                errorMsgElement.className = 'text-center text-red-400 italic';
                errorMsgElement.textContent = `Search failed: ${error.message || 'Please try again.'}`;
                if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none'; 
                if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
                resultsContainer.appendChild(errorMsgElement);
                currentRank = null; 
                // Clear timer display on error
                const timerIndicator = document.getElementById('search-timer-indicator');
                if (timerIndicator) timerIndicator.textContent = '';
            } finally {
                if(loadingIndicator) loadingIndicator.classList.add('hidden');
                searchInput.disabled = false;
                searchButton.disabled = selectedBookFilenames.length === 0; 
            }
        }

        // --- Search Event Listeners ---
        if (searchInput) {
            searchInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') triggerSearch();
            });
        }
        if (searchButton) {
            searchButton.addEventListener('click', triggerSearch);
        }

        // --- Overlap Removal Function ---
        function removeOverlap(chunk1, chunk2) {
            if (!chunk1 || !chunk2) return chunk2; 
            chunk1 = chunk1.trim();
            chunk2 = chunk2.trim();
            let maxOverlapLength = 0;
            for (let i = 1; i <= Math.min(chunk1.length, chunk2.length); i++) {
                if (chunk1.endsWith(chunk2.substring(0, i))) {
                    maxOverlapLength = i;
                }
            }
            if (maxOverlapLength > 0) {
                console.log(`Overlap found: ${maxOverlapLength} chars. Removing.`);
                return chunk2.substring(maxOverlapLength);
            }
            return chunk2;
        }
        
        // --- Get Full Chunk Text Helper (with context) ---
        async function getFullChunkText(index, filename) {
            const cacheKey = `${filename}-${index}`; 
            if (chunkFullTextCache[cacheKey] !== undefined) return chunkFullTextCache[cacheKey];
            if (!filename) throw new Error("Missing book context for chunk fetch.");
            
            const resp = await fetch('/get_chunk_text', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ book_filename: filename, chunk_index: index })
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status} fetching chunk ${index} from ${filename}`);
            const data = await resp.json();
            chunkFullTextCache[cacheKey] = data.text;
            return data.text;
        }

        // --- Fetch and Display Adjacent Chunk (with context) ---
        async function fetchChunkText(targetIndex, direction) {
            if (!currentResultBookFilename || targetIndex === null) return;

            const resultCard = resultsContainer.querySelector('.result-card');
            if (!resultCard) return; // Exit if result card not found
            const chunkTextElement = resultCard.querySelector('.chunk-text');
            const chunkIndexElem = resultCard.querySelector('.chunk-index');
            const prevBtn = resultCard.querySelector('.prev-chunk-button');
            const nextBtn = resultCard.querySelector('.next-chunk-button');

            try {
                const targetFull = await getFullChunkText(targetIndex, currentResultBookFilename); 
                let displayTxt = targetFull;                            

                if (targetIndex !== originalChunkIndex) {                 
                    if (direction === 'next' && targetIndex > 0) {
                        const prevFull = await getFullChunkText(targetIndex - 1, currentResultBookFilename);
                        displayTxt = removeOverlap(prevFull, targetFull);
                    } else if (direction === 'previous' && targetIndex > 0) {
                        const prevPrevFull = await getFullChunkText(targetIndex - 1, currentResultBookFilename);
                        displayTxt = removeOverlap(prevPrevFull, targetFull);
                    } else if (direction === 'previous' && targetIndex === 0) {
                         // Fetching the very first chunk (index 0) when moving previous
                         // No prior chunk to remove overlap from, just display targetFull
                         displayTxt = targetFull;
                    }
                }

                if (chunkTextElement) chunkTextElement.textContent = displayTxt;
                if (chunkIndexElem) chunkIndexElem.textContent = targetIndex;

                currentChunkIndex = targetIndex;
                currentFullChunkText = targetFull;

                if (prevBtn) prevBtn.disabled = currentChunkIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentChunkIndex >= totalChunks - 1;

            } catch (err) {
                console.error('Error fetching chunk:', err);
                if (chunkTextElement) chunkTextElement.textContent = 'Error loading chunk.';
            }
        }

        // --- Display Results Function ---
        function displayResults(results) {
            resultsContainer.innerHTML = ''; 
            if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none'; 
            if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
            resetGlobalFeedbackButtons(); 

            // --- Search Time Tracker: Log elapsed time ---
            if (searchStartTime !== null) {
                const elapsed = (performance.now() - searchStartTime) / 1000;
                console.log(`%cSearch completed in ${elapsed.toFixed(2)} seconds`, 'color: #a3e635;');
                const timerIndicator = document.getElementById('search-timer-indicator');
                if (timerIndicator) timerIndicator.textContent = `Search: ${elapsed.toFixed(2)}s`;
                searchStartTime = null;
            }

            if (!results || results.length === 0) {
                resultsContainer.innerHTML = '<p class="text-gray-500">No results found.</p>';
                currentRank = null; 
                currentResultBookFilename = null;
                return;
            }

            const result = results[0]; // Expecting list with one item
            
            originalChunkIndex = result.chunk_index;
            currentChunkIndex = result.chunk_index;
            totalChunks = result.total_chunks;
            currentFullChunkText = result.text;
            currentRank = result.rank; 
            
            // Use the book_filename from the backend result
            currentResultBookFilename = result.book_filename;
            if (!availableBooks.some(b => b.filename === currentResultBookFilename)) {
                console.warn(`Result book_filename ${currentResultBookFilename} not found in availableBooks. Navigation/Feedback might fail.`);
            } else {
                 console.log(`Set result context filename: ${currentResultBookFilename}`);
            }

            // Reset and prime cache
            chunkFullTextCache = {};              
            const cacheKey = `${currentResultBookFilename}-${originalChunkIndex}`;
            chunkFullTextCache[cacheKey] = result.text;

            // Clone and populate template
            const template = document.getElementById('resultTemplate');
            const resultCard = template.content.cloneNode(true).querySelector('.result-card');
            if (resultCard) { // Ensure card was found
                const titleEl = resultCard.querySelector('.book-title');
                const indexEl = resultCard.querySelector('.chunk-index');
                const textEl = resultCard.querySelector('.chunk-text');
                if (titleEl) titleEl.textContent = result.book_name;
                if (indexEl) indexEl.textContent = result.chunk_index;
                if (textEl) textEl.textContent = result.text;
                setupNavigationButtons(resultCard, result.chunk_index, result.total_chunks);
                resultsContainer.appendChild(resultCard);
                if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'flex';
                // Clipboard logic
                const copyBtn = resultCard.querySelector('.copy-chunk-btn');
                const chunkTextEl = resultCard.querySelector('.chunk-text');
                const tooltip = resultCard.querySelector('.copy-tooltip');
                if (copyBtn && chunkTextEl && tooltip) {
                    copyBtn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(chunkTextEl.textContent);
                            tooltip.style.opacity = '1';
                            setTimeout(() => { tooltip.style.opacity = '0'; }, 1200);
                        } catch (err) {
                            tooltip.textContent = 'Failed!';
                            tooltip.style.opacity = '1';
                            setTimeout(() => {
                                tooltip.textContent = 'Copied!';
                                tooltip.style.opacity = '0';
                            }, 1200);
                        }
                    });
                }
            } else {
                 console.error("Could not find .result-card in template.");
                 resultsContainer.innerHTML = '<p class="text-red-500">Error displaying result.</p>';
            }
        }

        // --- Set Up Navigation Buttons Function ---
        function setupNavigationButtons(cardElement, chunkIndex, totalChunksForBook) {
            const navigationDiv = cardElement.querySelector('.navigation-buttons');
            const prevButton = cardElement.querySelector('.prev-chunk-button');
            const nextButton = cardElement.querySelector('.next-chunk-button');
            if (!prevButton || !nextButton || !navigationDiv) return; 

            navigationDiv.style.display = 'flex'; 
            prevButton.disabled = chunkIndex <= 0;
            nextButton.disabled = chunkIndex >= totalChunksForBook - 1; 

            // Clone to remove old listeners
            const newPrevButton = prevButton.cloneNode(true);
            const newNextButton = nextButton.cloneNode(true);
            prevButton.parentNode.replaceChild(newPrevButton, prevButton);
            nextButton.parentNode.replaceChild(newNextButton, nextButton);
            
            // Add new listeners
            newPrevButton.addEventListener('click', () => fetchChunkText(currentChunkIndex - 1, 'previous')); 
            newNextButton.addEventListener('click', () => fetchChunkText(currentChunkIndex + 1, 'next')); 
            newPrevButton.disabled = chunkIndex <= 0; // Re-apply disabled state
            newNextButton.disabled = chunkIndex >= totalChunksForBook - 1; // Re-apply disabled state
        }

        // --- Reset Global Feedback Buttons Function ---
        function resetGlobalFeedbackButtons() {
             if (globalLikeButton) {
                 globalLikeButton.disabled = false;
                 globalLikeButton.classList.remove('opacity-50', 'pointer-events-none');
             }
             if (globalDislikeButton) {
                 globalDislikeButton.disabled = false;
                 globalDislikeButton.classList.remove('opacity-50', 'pointer-events-none');
             }
        }

        // --- Global Feedback Button Listeners ---
        if (globalLikeButton) globalLikeButton.addEventListener('click', () => sendFeedback(true));
        if (globalDislikeButton) globalDislikeButton.addEventListener('click', () => sendFeedback(false));

        // --- Send Feedback Function ---
        async function sendFeedback(isCorrect) {
             const query = searchInput.value;
             const chunkIndex = currentChunkIndex; 
             const bookFilenameForFeedback = currentResultBookFilename; 
             const rank = currentRank; 
             const allSearchedBooks = selectedBookFilenames; // List of books searched

             if (query === null || chunkIndex === null || bookFilenameForFeedback === null || !allSearchedBooks || allSearchedBooks.length === 0) {
                 console.error('Cannot send feedback: Missing context (query, index, result book, or searched books list).');
                 alert('Could not send feedback. State missing.');
                 return;
             }

             console.log('Sending Feedback:', { query, chunkIndex, isCorrect, selectedBooks: allSearchedBooks, rank });

             if (globalLikeButton) globalLikeButton.disabled = true;
             if (globalDislikeButton) globalDislikeButton.disabled = true;
             if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none';
             if (globalFeedbackSentMessage) {
                globalFeedbackSentMessage.textContent = 'Sending...';
                globalFeedbackSentMessage.classList.remove('text-red-400');
                globalFeedbackSentMessage.style.display = 'inline';
             }

             try {
                 const response = await fetch('/feedback', {
                     method: 'POST',
                     headers: {'Content-Type': 'application/json'},
                     body: JSON.stringify({
                         query: query,
                         chunk_index: chunkIndex,
                         is_correct: isCorrect,
                         selected_books: allSearchedBooks, 
                         rank: rank
                     }),
                 });
                 if (!response.ok) throw new Error(response.statusText);
                 console.log('Feedback sent successfully.');
                 if (globalFeedbackSentMessage) globalFeedbackSentMessage.textContent = 'Feedback Sent!';
             } catch (error) {
                 console.error('Error sending feedback:', error);
                 resetGlobalFeedbackButtons(); // Allow retry
                 if (globalFeedbackSentMessage) {
                     globalFeedbackSentMessage.textContent = 'Error saving feedback.';
                     globalFeedbackSentMessage.classList.add('text-red-400');
                 }
                 // Optionally show buttons again on error
                 if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'flex';
             }
         }

        // --- Initialize on DOM Load ---
        document.addEventListener('DOMContentLoaded', () => {
             if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none';
             if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
             currentRank = null; 
        });

    </script>
</body>
</html> 