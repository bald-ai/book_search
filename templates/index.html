<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codex Search - Find Passages in Your Favorite Books</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d3748; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }
        /* Placeholder text style */
        ::placeholder { color: #a0aec0; opacity: 1; }
        /* Title pulse animation */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .8; } }
        .title-pulse { animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        /* Styling for active toggle button */
        .book-toggle-active { background-color: #6b46c1; border-color: #5b21b6; color: #ffffff; }
        /* Styling for inactive toggle button */
        .book-toggle-inactive { background-color: #4a5568; border-color: #2d3748; color: #e2e8f0; }
        .book-toggle-inactive:hover { background-color: #718096; }
        /* Feedback text area styling */
        .feedback-textarea {
            background-color: #2d3748; /* gray-800 */
            border: 1px solid #4a5568; /* gray-600 */
            color: #e2e8f0; /* gray-200 */
        }
        .feedback-textarea:focus {
            outline: none;
            border-color: #6b46c1; /* purple-700 */
            box-shadow: 0 0 0 2px rgba(107, 70, 193, 0.5); /* Ring effect */
        }
        /* Disabled send button style */
        .send-feedback-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Added styles for search button */
        .search-button {
            background-color: #6b46c1; /* purple-700 */
            color: white;
            padding: 0.75rem 1.5rem; /* Adjust padding as needed */
            border: none;
            border-radius: 9999px; /* full */
            font-weight: 500; /* medium */
            transition: background-color 0.15s ease-in-out;
            cursor: pointer;
        }
        .search-button:hover {
            background-color: #5b21b6; /* purple-800 */
        }
        .search-button:focus {
             outline: none;
             box-shadow: 0 0 0 3px rgba(107, 70, 193, 0.4); /* Ring focus */
        }
        .search-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #4a5568; /* gray-600 */
        }
        /* Simple spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            display: inline-block;
            border: 3px solid rgba(196, 181, 253, 0.3); /* purple-300 opacity 30% */
            border-radius: 50%;
            border-top-color: #a78bfa; /* purple-400 */
            width: 1.25rem; /* size-5 */
            height: 1.25rem; /* size-5 */
            animation: spin 1s ease-in-out infinite;
            margin-right: 0.5rem; /* mr-2 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center px-4 py-8">

    <header class="text-center mb-8">
        <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 mb-2 title-pulse">
            Codex Search
        </h1>
        <p class="text-lg text-gray-400">Uncover passages within your favorite fantasy & sci-fi worlds.</p>
    </header>

    <section class="w-full max-w-3xl mb-8">
        <h3 class="text-lg font-semibold text-gray-400 mb-4 text-center">Select Book to Search:</h3>
        <div id="book-toggle-container" class="flex flex-wrap justify-center gap-3">
            <!-- Book buttons will be dynamically inserted here -->
        </div>
    </section>

    <section class="w-full max-w-2xl mb-4">
        <div class="flex items-center gap-3">
            <div class="relative flex-grow">
                <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none">
                    <svg class="h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" />
                    </svg>
                </div>
                <input
                    type="text"
                    id="searchInput"
                    placeholder="Select a book above and start searching..."
                    class="w-full pl-11 pr-10 py-3 bg-gray-800 border border-gray-700 text-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-300 ease-in-out"
                />
                <!-- Custom Clear Button -->
                <button id="clearSearchButton" class="absolute inset-y-0 right-0 flex items-center pr-3 text-[#ac36c9] hover:text-[#e61947] focus:outline-none" style="display: none;"> <!-- Hidden initially, Changed text color and hover color -->
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <button id="searchButton" class="search-button flex-shrink-0">
                Search
            </button>
        </div>
    </section>

    <section class="w-full max-w-2xl mb-8">
         <p id="select-book-prompt" class="text-center text-yellow-400 text-sm italic">
             Please select a book above to enable search.
         </p>
    </section>

    <section class="w-full max-w-3xl">
        <!-- Modified Heading with Feedback Buttons -->
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-semibold text-gray-300 md:text-left">Result</h2>
            <div class="flex items-center space-x-2">
                 <!-- Moved Feedback Buttons -->
                <div id="global-feedback-buttons" class="flex space-x-2" style="display: none;"> <!-- Initially hidden -->
                    <button id="global-like-button"
                            class="like-button p-2 rounded-full text-green-100 bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-green-500 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                            title="Good Result">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z" />
                        </svg>
                    </button>
                    <button id="global-dislike-button"
                            class="dislike-button p-2 rounded-full text-red-100 bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-red-500 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                            title="Bad Result">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M18 9.5a1.5 1.5 0 11-3 0v-6a1.5 1.5 0 013 0v6zM14 9.667v-5.43a2 2 0 00-1.106-1.79l-.05-.025A4 4 0 0011.057 2H5.642a2 2 0 00-1.962 1.608l-1.2 6A2 2 0 004.44 12H8v4a2 2 0 002 2 1 1 0 001-1v-.667a4 4 0 01.8-2.4l1.2-2.4A4 4 0 0014 9.667z" />
                        </svg>
                    </button>
                </div>
                <!-- Moved Feedback Sent Message -->
                 <div id="global-feedback-sent-message" class="text-sm text-gray-500" style="display: none;">Feedback Sent!</div>
            </div>
        </div>

        <!-- Loading Indicator (hidden by default) -->
        <div id="loading-indicator" class="hidden text-center text-purple-400 mb-4 flex items-center justify-center">
             <div class="spinner"></div>
             <span>Searching...</span>
        </div>

        <!-- Example Result Card (Template, hidden by default) -->
        <div class="result-card bg-gray-800 border border-gray-700 rounded-lg shadow-lg p-6 mb-6 transition duration-300 hover:shadow-purple-500/30 hidden">
            <p class="result-text text-gray-300 leading-relaxed mb-4">
                Placeholder text...
            </p>
            <div class="flex justify-between items-center mb-3">
                <span class="result-info text-sm text-purple-400 font-medium">Book Name - Chunk Index</span>
                <div class="flex space-x-3">
                    <button title="Good result" class="feedback-button thumbs-up p-2 rounded-full text-gray-400 hover:bg-green-700 hover:text-white transition duration-150 ease-in-out">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                          <path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z" />
                        </svg>
                    </button>
                    <button title="Bad result" class="feedback-button thumbs-down p-2 rounded-full text-gray-400 hover:bg-red-700 hover:text-white transition duration-150 ease-in-out">
                       <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                         <path d="M18 9.5a1.5 1.5 0 11-3 0v-6a1.5 1.5 0 013 0v6zM14 9.667v-5.43a2 2 0 00-1.106-1.79l-.05-.025A4 4 0 0011.057 2H5.642a2 2 0 00-1.962 1.608l-1.2 6A2 2 0 004.44 12H8v4a2 2 0 002 2 1 1 0 001-1v-.667a4 4 0 01.8-2.4l1.2-2.4A4 4 0 0014 9.667z" />
                       </svg>
                    </button>
                </div>
            </div>
            <div class="feedback-input-area hidden mt-3">
                <textarea
                    rows="3"
                    placeholder="What was wrong with this result?"
                    class="feedback-textarea w-full p-2 rounded-md text-sm transition duration-150 ease-in-out mb-2"
                ></textarea>
                <button
                    class="send-feedback-button w-full sm:w-auto bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled
                >
                    Send Feedback
                </button>
            </div>
        </div>

        <!-- Area where dynamic result will be loaded -->
        <div id="results-container" class="mt-6 space-y-4">
            <!-- Results will be dynamically inserted here -->
        </div>

    </section>

    <footer class="mt-16 text-center text-gray-500 text-sm">
        <p>&copy; 2025 Codex Search. All rights reserved.</p>
        <p>Powered by Vector Search & LLMs</p>
    </footer>

    <!-- Hidden template for search results -->
    <template id="resultTemplate">
        <div class="bg-white shadow-md rounded-lg p-6 mb-4 fade-in result-card">
            <div class="flex justify-between items-start mb-3">
                <div>
                    <h3 class="text-lg font-semibold text-gray-800 mb-1">Result from: <span class="font-normal book-title"></span></h3>
                    <p class="text-sm text-gray-500">Chunk Index: <span class="chunk-index font-medium"></span></p>
                    <!-- <p class="text-sm text-gray-500">Relevance Score: <span class="score"></span></p> -->
                </div>
                <!-- Feedback buttons removed from here -->
            </div>
            <p class="text-gray-700 whitespace-pre-wrap chunk-text"></p>

            <!-- Navigation Buttons -->
            <div class="mt-4 pt-4 border-t border-gray-200 flex justify-between navigation-buttons" style="display: none;"> <!-- Hidden initially -->
                <button class="prev-chunk-button px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                    &larr; Previous Chunk
                </button>
                <button class="next-chunk-button px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                    Next Chunk &rarr;
                </button>
            </div>
        </div>
    </template>

    <script>
        // --- Available Books (Dynamically Determined) ---
        // In a real Flask app, this would be passed from the backend.
        // For now, we simulate based on the files found.
        const availableBooks = [
            { filename: "promise_of_blood_embeded.json", title: "Promise of Blood" },
            { filename: "the_crimson_campaign_embeded.json", title: "The Crimson Campaign" },
            { filename: "the_autumn_republic_embeded.json", title: "The Autumn Republic" },
            { filename: "sins_of_empire_embeded.json", title: "Sins of Empire" },
            { filename: "wrath_of_empire_embeded.json", title: "Wrath of Empire" },
            { filename: "blood_of_empire_embeded.json", title: "Blood of Empire" },
        ];

        // --- DOM Elements ---
        const bookToggleContainer = document.getElementById('book-toggle-container');
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const resultsContainer = document.getElementById('results-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const selectBookPrompt = document.getElementById('select-book-prompt');
        // --- NEW: Custom Clear Button Element ---
        const clearSearchButton = document.getElementById('clearSearchButton');
        // --- State for Navigation ---
        let currentChunkIndex = null;
        let totalChunks = 0;
        let currentFullChunkText = null; // Store the full text of the current chunk
        // --- Global Feedback Elements ---
        const globalFeedbackButtonsDiv = document.getElementById('global-feedback-buttons');
        const globalLikeButton = document.getElementById('global-like-button');
        const globalDislikeButton = document.getElementById('global-dislike-button');
        const globalFeedbackSentMessage = document.getElementById('global-feedback-sent-message');
        let selectedBookFilename = null;
        let selectedBookTitle = null;
        // --- Navigation / trimming state (NEW) ---
        let originalChunkIndex   = null;     // remember first result (x)
        let chunkFullTextCache   = {};       // {index: fullChunkText}
        let currentRank          = null;     // <<< Add state for rank

        // --- Populate Book Toggles ---
        availableBooks.forEach(book => {
            const button = document.createElement('button');
            button.className = 'book-toggle book-toggle-inactive px-4 py-2 rounded-full border-2 transition duration-150 ease-in-out text-sm font-medium';
            button.dataset.bookFilename = book.filename;
            button.dataset.bookTitle = book.title;
            button.textContent = book.title;
            bookToggleContainer.appendChild(button);
        });

        // --- Book Toggle Functionality ---
        const bookToggles = document.querySelectorAll('.book-toggle');

        bookToggles.forEach(button => {
            button.addEventListener('click', () => {
                const bookFilename = button.dataset.bookFilename;
                const bookTitle = button.dataset.bookTitle;
                const isCurrentlyActive = button.classList.contains('book-toggle-active');

                // Deactivate all buttons first
                bookToggles.forEach(btn => {
                    btn.classList.remove('book-toggle-active');
                    btn.classList.add('book-toggle-inactive');
                });

                if (!isCurrentlyActive) {
                    button.classList.remove('book-toggle-inactive');
                    button.classList.add('book-toggle-active');
                    selectedBookFilename = bookFilename;
                    selectedBookTitle = bookTitle;
                    searchInput.placeholder = `Search in ${bookTitle}...`;
                    searchInput.disabled = false;
                    searchButton.disabled = false;
                    if(selectBookPrompt) selectBookPrompt.classList.add('hidden');
                } else {
                    // If clicking the active button, deactivate it and reset placeholder
                    selectedBookFilename = null;
                    selectedBookTitle = null;
                    searchInput.placeholder = 'Select a book above and start searching...';
                    searchInput.disabled = true;
                    searchButton.disabled = true;
                    if(selectBookPrompt) selectBookPrompt.classList.remove('hidden');
                }
                console.log('Selected book file:', selectedBookFilename);
                // Clear previous results and reset navigation state when book selection changes
                resultsContainer.innerHTML = '';
                currentChunkIndex = null;
                totalChunks = 0;
                if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none'; // Hide feedback buttons
                if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
                resetGlobalFeedbackButtons(); // Reset their state
                currentRank = null; // <<< Reset rank on book change
            });
        });

        // --- NEW: Clear Button Logic ---
        if (searchInput && clearSearchButton) {
            searchInput.addEventListener('input', () => {
                // Show button only if there is text
                clearSearchButton.style.display = searchInput.value.length > 0 ? 'flex' : 'none';
            });

            clearSearchButton.addEventListener('click', () => {
                searchInput.value = ''; // Clear the input
                clearSearchButton.style.display = 'none'; // Hide the button
                searchInput.focus(); // Optionally focus back on the input
                // If clearing the input should also clear results, add that logic here
                // resultsContainer.innerHTML = '';
                // Reset other state if needed
            });
        }

        // Disable search initially and ensure prompt is visible
        searchInput.disabled = true;
        searchButton.disabled = true;
        if(selectBookPrompt) selectBookPrompt.classList.remove('hidden');

        // --- Function to Trigger Search --- (Refactored)
        async function triggerSearch() {
            if (!selectedBookFilename || searchInput.value.trim() === '') {
                console.log('Search not triggered: Book not selected or query empty.');
                return;
            }

            const query = searchInput.value.trim();
            console.log(`Triggering search for: \"${query}\" in book: ${selectedBookFilename}`);

            // Show loading indicator and disable inputs
            resultsContainer.innerHTML = '';
            if(loadingIndicator) loadingIndicator.classList.remove('hidden');
            searchInput.disabled = true;
            searchButton.disabled = true;
            bookToggles.forEach(btn => btn.disabled = true);

            console.log('%cStarting search process...', 'color: #a78bfa;'); // Purple color

            try {
                const response = await fetch('/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query: query, book_filename: selectedBookFilename })
                });

                const responseData = await response.json();

                if (!response.ok) {
                    const errorMsg = responseData.error || `HTTP error! status: ${response.status}`;
                    throw new Error(errorMsg);
                }

                // Log based on the backend flag
                if (responseData.search_completed) {
                    console.log('%cLLM refinement step was likely attempted (search function completed).', 'color: #34d399;'); // Green color
                } else {
                    console.log('%cLLM refinement step likely not reached (search function did not complete).', 'color: #f87171;'); // Red color
                }

                // Adjust how results are accessed from the new response structure
                displayResults(responseData.results || [], selectedBookTitle || selectedBookFilename.replace('_embeded.json', ''), responseData.total_chunks);

                console.log('%cSearch complete.', 'color: #60a5fa;'); // Blue color

            } catch (error) {
                currentChunkIndex = null; // Reset state on error
                totalChunks = 0;
                console.error('Search failed:', error);
                resultsContainer.innerHTML = '';
                const errorMsgElement = document.createElement('p');
                errorMsgElement.className = 'text-center text-red-400 italic';
                errorMsgElement.textContent = `Search failed: ${error.message || 'Please try again.'}`;
                if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none'; // Hide feedback buttons on error
                if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
                resultsContainer.appendChild(errorMsgElement);
                currentRank = null; // <<< Reset rank on error
            } finally {
                if(loadingIndicator) loadingIndicator.classList.add('hidden');
                searchInput.disabled = false;
                searchButton.disabled = !selectedBookFilename;
                 bookToggles.forEach(btn => btn.disabled = false);
            }
        }

        // --- Event Listeners for Search ---
        if (searchInput) {
            searchInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    triggerSearch();
                }
            });
        }

        if (searchButton) {
            searchButton.addEventListener('click', () => {
                triggerSearch();
            });
        }

        // --- Function to remove overlap ---
        function removeOverlap(chunk1, chunk2) {
            if (!chunk1 || !chunk2) return chunk2; // Handle edge cases

            chunk1 = chunk1.trim();
            chunk2 = chunk2.trim();
            let maxOverlapLength = 0;

            // Find the longest suffix of chunk1 that is a prefix of chunk2
            for (let i = 1; i <= Math.min(chunk1.length, chunk2.length); i++) {
                const suffix = chunk1.substring(chunk1.length - i);
                const prefix = chunk2.substring(0, i);
                if (suffix === prefix) {
                    maxOverlapLength = i;
                }
            }

            // Return chunk2 with the overlapping prefix removed
            if (maxOverlapLength > 0) {
                // Be cautious: if overlap is almost the entire chunk, maybe don't remove?
                // For now, remove whatever overlap is found.
                // Consider adding a threshold if needed.
                console.log(`Overlap found: ${maxOverlapLength} characters. Removing from start of next chunk.`);
                return chunk2.substring(maxOverlapLength);
            }

            console.log("No overlap found between current and next chunk.");
            return chunk2; // No overlap found
        }

        // -- little util so we never fetch the same chunk twice --
        async function getFullChunkText(index) {
            if (chunkFullTextCache[index] !== undefined) return chunkFullTextCache[index];

            const resp  = await fetch('/get_chunk_text', {
                            method : 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body   : JSON.stringify({ book_filename: selectedBookFilename,
                                                      chunk_index   : index })
                         });

            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

            const data  = await resp.json();
            chunkFullTextCache[index] = data.text;
            return data.text;
        }

        // --- Fetch + show a chunk, applying EXACT trimming rules ---
        async function fetchChunkText(targetIndex, direction) {
            if (!selectedBookFilename || targetIndex === null) return;

            const resultCard       = resultsContainer.querySelector('.result-card');
            const chunkTextElement = resultCard.querySelector('.chunk-text');
            const chunkIndexElem   = resultCard.querySelector('.chunk-index');
            const prevBtn          = resultCard.querySelector('.prev-chunk-button');
            const nextBtn          = resultCard.querySelector('.next-chunk-button');

            try {
                /* ------- grab full text(s) we need ------- */
                const targetFull = await getFullChunkText(targetIndex);   // chunkN-1 or chunkN+1 etc.
                let   displayTxt = targetFull;                            // what we'll finally show

                /* ---------- Decide whether to trim ---------- */
                if (targetIndex !== originalChunkIndex) {                 // never trim original x
                    if (direction === 'next') {
                        // we need chunkN (the one we're coming FROM)
                        const prevFull = await getFullChunkText(targetIndex - 1);
                        displayTxt     = removeOverlap(prevFull, targetFull);

                    } else if (direction === 'previous' && targetIndex > 0) {
                        // we need chunkN-2
                        // Fetch the text of the chunk *before* the one we are moving to (targetIndex - 1 == N-2)
                        const prevPrevFull = await getFullChunkText(targetIndex - 1);
                        // Remove overlap between N-2 and N-1 (the target)
                        displayTxt         = removeOverlap(prevPrevFull, targetFull);
                    }
                }

                /* ---------- push to UI ---------- */
                chunkTextElement.textContent = displayTxt;
                chunkIndexElem.textContent   = targetIndex;

                // update navigation state
                currentChunkIndex    = targetIndex;
                currentFullChunkText = targetFull; // Always store the full text in state

                prevBtn.disabled = currentChunkIndex <= 0;
                nextBtn.disabled = currentChunkIndex >= totalChunks - 1;

            } catch (err) {
                console.error('Error fetching chunk:', err);
                chunkTextElement.textContent = 'Error loading chunk.';
            }
        }

        // --- Function to Display Results --- (Modified to call setupNavigationButtons)
        function displayResults(results, bookTitle, totalChunkCount) {
            resultsContainer.innerHTML = ''; // Clear previous results or loading
            if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none'; // Hide global buttons initially
            if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
            resetGlobalFeedbackButtons(); // Ensure buttons are clickable

            if (!results || results.length === 0) {
                resultsContainer.innerHTML = '<p class="text-gray-500">No results found.</p>';
                currentRank = null; // <<< Reset rank if no results
                return;
            }

            // Assuming the backend now always returns a single best result in a list
            const result = results[0];
            // remember original chunk + cache it
            originalChunkIndex        = result.chunk_index;
            currentChunkIndex         = result.chunk_index;
            totalChunks               = totalChunkCount;
            currentFullChunkText      = result.text;
            currentRank               = result.rank; // <<< Store the rank

            chunkFullTextCache        = {};              // reset cache for a new search
            chunkFullTextCache[originalChunkIndex] = result.text;

            const template = document.getElementById('resultTemplate');
            const resultCard = template.content.cloneNode(true).querySelector('.result-card');

            resultCard.querySelector('.book-title').textContent = bookTitle;
            resultCard.querySelector('.chunk-index').textContent = result.chunk_index;
            resultCard.querySelector('.chunk-text').textContent = result.text; // Display original text first
           // resultCard.querySelector('.score').textContent = result.score !== undefined ? result.score.toFixed(4) : 'N/A';

            // Setup Navigation
            setupNavigationButtons(resultCard, result.chunk_index, totalChunks);

            resultsContainer.appendChild(resultCard);

            // Show global feedback buttons now that a result is displayed
            if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'flex';
        }

        // --- Function to Set Up Navigation Buttons --- (Modified to pass direction)
        function setupNavigationButtons(cardElement, chunkIndex, totalChunks) {
            const navigationDiv = cardElement.querySelector('.navigation-buttons');
            const prevButton = cardElement.querySelector('.prev-chunk-button');
            const nextButton = cardElement.querySelector('.next-chunk-button');

            if (!prevButton || !nextButton || !navigationDiv) return; // Safety check

            navigationDiv.style.display = 'flex'; // Make sure buttons are visible

            prevButton.disabled = chunkIndex <= 0;
            nextButton.disabled = chunkIndex >= totalChunks - 1;

            // Remove previous listeners to prevent duplicates if called multiple times
            prevButton.replaceWith(prevButton.cloneNode(true));
            nextButton.replaceWith(nextButton.cloneNode(true));
            // Get the new buttons after cloning
            const newPrevButton = cardElement.querySelector('.prev-chunk-button');
            const newNextButton = cardElement.querySelector('.next-chunk-button');


            if (newPrevButton) {
                 newPrevButton.addEventListener('click', () => fetchChunkText(currentChunkIndex - 1, 'previous')); // Pass direction
                 newPrevButton.disabled = chunkIndex <= 0; // Ensure state is correct after clone
            }
             if (newNextButton) {
                 newNextButton.addEventListener('click', () => fetchChunkText(currentChunkIndex + 1, 'next')); // Pass direction
                 newNextButton.disabled = chunkIndex >= totalChunks - 1; // Ensure state is correct after clone
            }
        }

        // --- Function to Reset Global Feedback Buttons --- (New)
        function resetGlobalFeedbackButtons() {
             if (globalLikeButton) {
                 globalLikeButton.disabled = false;
                 globalLikeButton.classList.remove('opacity-50', 'pointer-events-none');
             }
             if (globalDislikeButton) {
                 globalDislikeButton.disabled = false;
                 globalDislikeButton.classList.remove('opacity-50', 'pointer-events-none');
             }
        }

        // --- Global Feedback Button Logic ---
        if (globalLikeButton) {
            globalLikeButton.addEventListener('click', () => {
                sendFeedback(true);
            });
        }

        if (globalDislikeButton) {
            globalDislikeButton.addEventListener('click', () => {
                sendFeedback(false);
            });
        }

        // --- Send Feedback (Modified for Global Buttons) --- (New)
        async function sendFeedback(isCorrect) {
             // Use global state for query, index, and book
             const query = searchInput.value;
             const chunkIndex = currentChunkIndex;
             const bookFilename = selectedBookFilename;
             const rank = currentRank; // <<< Get rank from global state

             if (query === null || chunkIndex === null || bookFilename === null) {
                 console.error('Cannot send feedback: Missing query, chunkIndex, or bookFilename in current state.');
                 alert('Could not send feedback. Please try searching again.');
                 return;
             }

             // Create a list for selected_books
             const selectedBooksList = [bookFilename];

             console.log('Calling sendFeedback with:', { query, chunkIndex, isCorrect, selectedBooks: selectedBooksList, rank });

             // Disable buttons immediately
             if (globalLikeButton) {
                 globalLikeButton.disabled = true;
                 globalLikeButton.classList.add('opacity-50', 'pointer-events-none');
             }
             if (globalDislikeButton) {
                 globalDislikeButton.disabled = true;
                 globalDislikeButton.classList.add('opacity-50', 'pointer-events-none');
             }
             // Hide buttons, show message
             if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none';
             if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'inline'; // Or block

             try {
                 const response = await fetch('/feedback', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({
                         query: query,
                         chunk_index: chunkIndex,
                         is_correct: isCorrect,
                         selected_books: selectedBooksList,
                         rank: rank
                     }),
                 });

                 if (!response.ok) {
                     console.error('Failed to send feedback:', response.statusText);
                     // Optionally re-enable buttons or show error to user
                     if (globalFeedbackSentMessage) {
                         globalFeedbackSentMessage.textContent = 'Error saving feedback.';
                         globalFeedbackSentMessage.classList.add('text-red-400');
                         globalFeedbackSentMessage.style.display = 'inline'; // Or block
                     }
                     if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'flex'; // Show buttons again on error to allow retry
                 } else {
                     console.log('Feedback sent successfully.');
                     // Keep buttons disabled and visually indicate success (already done by styling)
                     if (globalFeedbackSentMessage) {
                         globalFeedbackSentMessage.textContent = 'Feedback Sent!';
                         globalFeedbackSentMessage.classList.remove('text-red-400');
                     }
                 }
             } catch (error) {
                 console.error('Error sending feedback:', error);
                 // Reset buttons on error to allow retry?
                 resetGlobalFeedbackButtons(); // Maybe allow retry on error?
                 if (globalFeedbackSentMessage) {
                     globalFeedbackSentMessage.textContent = 'Error saving feedback.';
                     globalFeedbackSentMessage.classList.add('text-red-400');
                     globalFeedbackSentMessage.style.display = 'inline'; // Or block
                 }
                 if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'flex'; // Show buttons again on error to allow retry
             }
         }

        // --- Initialize Global Event Listeners --- (New)
        document.addEventListener('DOMContentLoaded', () => {
            // Remove redundant listeners from here
            /*
            if (globalLikeButton) {
                globalLikeButton.addEventListener('click', () => {
                    sendFeedback(true);
                });
            }
            if (globalDislikeButton) {
                globalDislikeButton.addEventListener('click', () => {
                    sendFeedback(false);
                });
            }
            */
            // Initial state: hide feedback buttons
             if (globalFeedbackButtonsDiv) globalFeedbackButtonsDiv.style.display = 'none';
             if (globalFeedbackSentMessage) globalFeedbackSentMessage.style.display = 'none';
             currentRank = null; // <<< Initialize rank state
        });

    </script>
</body>
</html> 